//Problem: There are multiple entries for numerical entries and they each register as one type.
//Must go through each column and append an appropriate id tag to numbers.
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Hashtable;
//import java.lang.Object.org.apache.jorphan.collections.HashTree;

public class Apriori {
	static int support = 9000;
	static String[][] Data;
	static boolean end = false;
	static Hashtable location;
	static ArrayList<String[]> aboveSupport = new ArrayList<String[]>();
	
	public static void main(String[] args)
	{
//Reads file into array correctly.
		try{
		Data = readLines();
		}catch(IOException e){System.out.println("Error" + e);}
		Apriori();
		for(int i=0; i<aboveSupport.size(); i++)
		{
			String[] temp = aboveSupport.get(i);
			for(int j=0; j<temp.length;j++)
				System.out.print(temp[j] + ", ");
			System.out.println();
		}
	}
    public static String[][] readLines() throws IOException {
        FileReader fileReader = new FileReader("adult.txt");
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        List<String[]> lines = new ArrayList<String[]>();
        String line = null;
        while ((line = bufferedReader.readLine()) != null) {
            lines.add(line.split(", "));
        }
        bufferedReader.close();
        String[][] temp = lines.toArray(new String[lines.size()][15]);
        String[][] finalArray = new String[temp.length][13];
//        System.out.println(finalArray.length);
/*Data reduction:
  Removed Country, almost all entries are in United States and there aren't enough from elsewhere for statistical significance.
  Removed fnlwgt (final weight), a numerical vector with no clear meaning.
  Removed education_number, because it's just a numerical representation of the existing education category.
*/
        for(int i=0; i<lines.size()-1; i++)
        {
//Divide age into five year intervals.
        	if(temp[i][0].charAt(1) <5)
        	{
				finalArray[i][0] = Character.toString(temp[i][0].charAt(0)) + "0age";
			}
			else
        	{
				finalArray[i][0] = Character.toString(temp[i][0].charAt(0)) + "5age";
			}
			finalArray[i][1] = temp[i][1];
			if(temp[i][3].equals("11th") || temp[i][3].equals("10th") || temp[i][3].equals("12th"))
				finalArray[i][2] = "SomeHS";
			else
				finalArray[i][2] = temp[i][3];
			finalArray[i][3] = temp[i][5];
			finalArray[i][4] = temp[i][6];
			finalArray[i][5] = temp[i][7];
			finalArray[i][6] = temp[i][8];
			finalArray[i][7] = temp[i][9];
			int cG = Integer.parseInt(temp[i][10]);
			if(cG>6000)
			{
				finalArray[i][8] = ">6000cG";
			}
			else if(cG>4000)
			{
				finalArray[i][8] = "4000cG-6000cG";
			}
			else if(cG>2000)
			{
				finalArray[i][8] = "2000cG-4000cG";
			}
			else if(cG>0)
			{
				finalArray[i][8] = "0cG-2000cG";
			}
			else
			{
				finalArray[i][8] = "0cG";
			}
			finalArray[i][9] = temp[i][11] + "capitalLoss";
			int hwp = Integer.parseInt(temp[i][12]);
			if(hwp>40)
			{
				finalArray[i][10] = ">40hpw";
			}
			else if(hwp>30)
			{
				finalArray[i][10] = "30hpw-40hpw";
			}
			else if(hwp>20)
			{
				finalArray[i][10] = "20hpw-30hpw";
			}
			else if(hwp>10)
			{
				finalArray[i][10] = "10hpw-20hpw";
			}
			else
			{
				finalArray[i][10] = ">10hpw";
			}
			finalArray[i][11] = temp[i][13];
			finalArray[i][12] = temp[i][14];
        }
        return finalArray;
    }
//Combines the two following methods.
    public static void Apriori()
    {
    	String[] L = generateInitL();
    	String[][] newL = CrossAll(L);
    	String[][] newC;
//While there are still itemsets above the support count, do. In two lines, the Apriori loop.
    	while(!end)
    	{
    		newC = Prune(newL);
    		newL = CrossAll(newC);
    	}
    }
    public static String[] generateInitC(String[][] input)
    {
    	ArrayList<String> returnString = new ArrayList<String>();
    	Hashtable table = new Hashtable();
    	location = new Hashtable();
    	for(int i=0; i<input.length-1;i++)
    		for(int j=0;j<input[i].length;j++)
    		{//System.out.println(input[i][j]);
    			if(!table.containsKey(input[i][j].hashCode()))
    			{
    				//System.out.println(input[i][j]);
    				table.put(input[i][j].hashCode(), input[i][j]);
//Keeps the position at which an input was found. Makes it so no third loop is necessary(each element doesn't have to pass the array, it knows where to check).
    				location.put(input[i][j].hashCode(), j);
    				returnString.add(input[i][j]);
    			}}
		String[] array = returnString.toArray(new String[returnString.size()]);
    	return array;
    }
//Generates L1 by running membershipTest() on all elements of the array generated by generateInitC().
//Since generateInitC() only takes arrays, a temporary single element array has to be generated in the for loop.
    public static String[] generateInitL()
    {
    	String[] C1 = generateInitC(Data);
    	ArrayList<String> tempList = new ArrayList<String>();
    	for(int i=0; i<C1.length; i++)
    	{
    		String[] temp = {C1[i]};
    		if(membershipTest(temp, Data))
    			tempList.add(C1[i]);
    	}
    	return tempList.toArray(new String[tempList.size()]);
    }
    public static String[][] CrossAll(String[][] one)
    {
//Not totally sure if you can do this, but lets try.
    	ArrayList<String[]> tempList = new ArrayList<String[]>();
//THIS IS THE MARK. THIS IS WHAT I'M TALKING ABOUT IN THE README.
    	for(int i=0; i<one.length; i++)
    		for(int j=i+1; j<one.length;j++)
    			tempList.add(Crossing(one[i], one[j]));
    	return tempList.toArray(new String[tempList.size()][12]);
    }
//Overloaded method takes L1 into account (it's a single dimensional array).
    public static String[][] CrossAll(String[] one)
    {
    	ArrayList<String[]> tempList = new ArrayList<String[]>();
    	for(int i=0; i<one.length; i++)
    		for(int j=i; j<one.length;j++)
    		{
    			String[] tempArray1 = {one[i]};
    			String[] tempArray2 = {one[j]};
    			if(!one[i].equals(one[j]))
    			tempList.add(Crossing(tempArray1,tempArray2));
    		}
    	return tempList.toArray(new String[tempList.size()][12]);
    }
//Generate C(k) by cross joining the itemsets of L(k-1) among themselves.A cross join between two k-item sets is a union of those two sets which results in a k+1 itemset. However, the join only happens if and only if the first k-1 items of both sets are equal.
    public static String[] Crossing(String[] one, String[] two)
    {
    	if(one.length != two.length)
    	{System.out.println("Error, arrays are improperly sized");
    		return one;
    	}
    	if(one.length==1)
    	{
    		String[] temp5 = {one[0],two[0]};
    		return temp5;
    	}
    		boolean x = true;
    		String[] RETURN = new String[one.length+1];
    		for(int i=0; i<one.length-1; i++)
    			if(!(one[i].equals(two[i])))
    				x=false;
    		if(x && !one[one.length-1].equals(two[one.length-1]))
    			for(int i=0;i<one.length;i++)
    				RETURN[i] = one[i];
//Append final element of two to RETURN array.
    		RETURN[one.length] = two[two.length-1];
    		return RETURN;
	}
	public static String[][] Prune(String[][] Ck)
	{
		List<String[]> temp = new ArrayList<String[]>();
		boolean x = false;
		for(int i=0; i<Ck.length; i++)
			if(membershipTest(Ck[i], Data))
			{	
				temp.add(Ck[i]);
				x=true;
			}
		if(!x)
			end = true;				
		return temp.toArray(new String[temp.size()][12]);
	}
//Go through each itemset in the input array (D) and check for membership. Keep a count of itemsets
//that C(k) is a member of. If the count >= support at the end, return true. Else return false.
	public static boolean membershipTest(String[] element, String[][] input)
	{//System.out.println("New Call" + element[0]);
	int count = 0;
//Check the membership of a C(k) in all itemsets.
	try
	{
		for(int x=0; x<input.length; x++)
		{
//Check the membership of a C(k) in a single itemset.
			boolean y = true;
			for(int i=0; i<element.length; i++)
			{//System.out.print(element[i] + ", ");
				int posit = (Integer) location.get(element[i].hashCode());
				if(!element[i].equals(input[x][posit]))
				{
					y=false;
					break;
				}
			}
			if(y)
				count++;
		}
	}catch (NullPointerException npe){}
	if(count>=support)
	{
		if(element.length >2)
			aboveSupport.add(element);
		return true;
	}
	return false;
	}
}